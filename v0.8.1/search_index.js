var documenterSearchIndex = {"docs":
[{"location":"types/#Command-Types","page":"Command Types","title":"Command Types","text":"","category":"section"},{"location":"types/","page":"Command Types","title":"Command Types","text":"The frontend @main and @cast restrict a lot features to make the package interface as simple as possible. However, if you want to customize the behaviour, you can also create command objects directly via the interfaces at this level, which are all in Comonicon.Types.","category":"page"},{"location":"types/#References","page":"Command Types","title":"References","text":"","category":"section"},{"location":"types/","page":"Command Types","title":"Command Types","text":"Modules = [Comonicon.Types]","category":"page"},{"location":"types/#Comonicon.Types.AbstractCommand","page":"Command Types","title":"Comonicon.Types.AbstractCommand","text":"AbstractCommand\n\nabstract type for commands.\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.Types.EntryCommand","page":"Command Types","title":"Comonicon.Types.EntryCommand","text":"EntryCommand <: AbstractCommand\n\nEntryCommand describes the entry of the CLI. It contains an actual root command (either LeafCommand or NodeCommand) of the entire CLI and a version number. The version number is v\"0.0.0\" by default.\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.Types.LeafCommand","page":"Command Types","title":"Comonicon.Types.LeafCommand","text":"LeafCommand <: AbstractCommand\n\nLeafCommand describes the command at the end of a CLI, e.g in the following show is LeafCommand, it is the command that actually executes things. See also NodeCommand.\n\ngit remote show origin\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.Types.NodeCommand","page":"Command Types","title":"Comonicon.Types.NodeCommand","text":"NodeCommand <: AbstractCommand\n\nNodeCommand describes the command in the middle of a CLI, e.g in the following remote is a NodeCommand, it will dispatch the call to its sub-command show. See also LeafCommand.\n\ngit remote show origin\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.Types.max_brief_length-Tuple{}","page":"Command Types","title":"Comonicon.Types.max_brief_length","text":"max_brief_length()\n\nGet the maximum length allowed for a brief description.\n\n\n\n\n\n","category":"method"},{"location":"types/#Comonicon.Types.print_cmd","page":"Command Types","title":"Comonicon.Types.print_cmd","text":"print_cmd([io, ]cmd)\n\nPrint a command object. This is used to generate command help.\n\n\n\n\n\n","category":"function"},{"location":"types/#Comonicon.Types.set_brief_length!","page":"Command Types","title":"Comonicon.Types.set_brief_length!","text":"set_brief_length!(n::Int=120)\n\nSet the maximum length of a brief description. Default is 120.\n\nnote: Note\nThis is only effective when called before @main or codegen.\n\n\n\n\n\n","category":"function"},{"location":"types/#Comonicon.Types.splittext-Tuple{String}","page":"Command Types","title":"Comonicon.Types.splittext","text":"splittext(s)\n\nSplit the text in string s into an array, but keep all the separators attached to the preceding word.\n\nnote: Note\nthis is copied from Luxor/text.jl\n\n\n\n\n\n","category":"method"},{"location":"parse/#Parse","page":"Command Parsing","title":"Parse","text":"","category":"section"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"This is the frontend @cast and @main of Comonicon.","category":"page"},{"location":"parse/#References","page":"Command Parsing","title":"References","text":"","category":"section"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"Modules = [Comonicon.Parse]","category":"page"},{"location":"parse/#Comonicon.Parse.cachedir","page":"Command Parsing","title":"Comonicon.Parse.cachedir","text":"cachedir([file=Base.PROGRAM_FILE])\n\nReturn the cache directory.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.Parse.cachefile","page":"Command Parsing","title":"Comonicon.Parse.cachefile","text":"cache_file([file=Base.PROGRAM_FILE])\n\nReturn the files that will be cached:\n\ncmd.jl: a julia script that contains the generated CLI code.\nchecksum: a checksum file for checking if the generated CLI code matches the original file.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.Parse.command","page":"Command Parsing","title":"Comonicon.Parse.command","text":"command(module; name=\"\", doc=docstring(m))\n\nConvert a module to a CLI command NodeCommand.\n\ncommand(f::Function, args, kwargs; name=\"\")\n\nConvert a function to a CLI command LeafCommand. It requires a Vector of function arguments and a Vector of function kwargs.\n\nThe element of arguments vector is a tuple (name, type, require):\n\nname::String is the name of argument\ntype::DataType is the type of this argument, can be Any if you don't want to specify\nrequire::Bool indicates the whether this argument is required.\nvararg::Bool indicates whether this argument is a vararg.\n\nThe element of kwargs vector is also a tuple (name, type, short):\n\nname::String is the name of kwarg\ntype::DataType is the type of this kwarg, can be Any if you don't want to specify\nshort::Bool is a flag that indicates whether this kwarg has short option.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.Parse.create_cache","page":"Command Parsing","title":"Comonicon.Parse.create_cache","text":"create_cache(cmd[, file=Base.PROGRAM_FILE])\n\nCreate cache for given command cmd at file location file.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.Parse.disable_cache-Tuple{}","page":"Command Parsing","title":"Comonicon.Parse.disable_cache","text":"disable_cache()\n\nDisable command compile cache. See also enable_cache.\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.Parse.enable_cache-Tuple{}","page":"Command Parsing","title":"Comonicon.Parse.enable_cache","text":"enable_cache()\n\nEnable command compile cache. See also disable_cache.\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.Parse.get_version-Tuple{Module}","page":"Command Parsing","title":"Comonicon.Parse.get_version","text":"get_version(m::Module)\n\nGet the version of a given module. It will try to find the version of Project.toml if the given module is a project module. If fails, it returns v\"0.0.0\".\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.Parse.iscached","page":"Command Parsing","title":"Comonicon.Parse.iscached","text":"iscached([file=Base.PROGRAM_FILE])\n\nCheck if the given file is cached or not.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.Parse.read_doc-Tuple{Markdown.MD}","page":"Command Parsing","title":"Comonicon.Parse.read_doc","text":"read_doc(markdown)\n\nRead CLI documentation from markdown format doc strings.\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.Parse.rm_format","page":"Command Parsing","title":"Comonicon.Parse.rm_format","text":"rm_format(md)\n\nRemove Markdown DOM and flatten to strings.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.Parse.set_cmd!","page":"Command Parsing","title":"Comonicon.Parse.set_cmd!","text":"set_cmd!(cmds::Dict, cmd)\n\nregister cmd in the command registry cmds, which usually is a constant CASTED_COMMANDS under given module.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.Parse.@cast-Tuple{Any}","page":"Command Parsing","title":"Comonicon.Parse.@cast","text":"@cast <function expr>\n@cast <module expr>\n@cast <function name>\n@cast <module name>\n\nCast a Julia object to a command object. @cast will always execute the given expression, and only create and register an command object via command after analysing the given expression.\n\nExample\n\nThe most basic way is to use @cast on a function as your command entry.\n\n@cast function your_command(arg1, arg2::Int)\n    # your processing code\nend\n\nThis will create a LeafCommand object and register it to the current module's CASTED_COMMANDS constant. You can access this object via MODULE_NAME.CASTED_COMMANDS[\"your_command\"].\n\nNote this will not create a functional CLI, to create a function CLI you need to create an entry point, which can be declared by @main.\n\n\n\n\n\n","category":"macro"},{"location":"parse/#Comonicon.Parse.@main-Tuple","page":"Command Parsing","title":"Comonicon.Parse.@main","text":"@main <function expr>\n@main\n\nCreate an EntryCommand and use it as the entry of the entire CLI. If you only have one function to cast to a CLI, you can use @main instead of @cast so it will create both the command object and the entry.\n\n\n\n\n\n","category":"macro"},{"location":"codegen/#Code-Generation","page":"Code Generation","title":"Code Generation","text":"","category":"section"},{"location":"codegen/","page":"Code Generation","title":"Code Generation","text":"This is the backend of Comonicon. Currently it can only generates a Julia AST.","category":"page"},{"location":"codegen/#References","page":"Code Generation","title":"References","text":"","category":"section"},{"location":"codegen/","page":"Code Generation","title":"Code Generation","text":"Modules = [Comonicon.CodeGen]","category":"page"},{"location":"codegen/#Comonicon.CodeGen.ASTCtx","page":"Code Generation","title":"Comonicon.CodeGen.ASTCtx","text":"ASTCtx\n\nAST code generation context.\n\n\n\n\n\n","category":"type"},{"location":"codegen/#Comonicon.CodeGen.codegen","page":"Code Generation","title":"Comonicon.CodeGen.codegen","text":"codegen(ctx, cmd)\n\nGenerate target code according to given context ctx from a command object cmd.\n\n\n\n\n\n","category":"function"},{"location":"codegen/#Comonicon.CodeGen.codegen-Tuple{Comonicon.Types.AbstractCommand}","page":"Code Generation","title":"Comonicon.CodeGen.codegen","text":"codegen(cmd)\n\nGenerate Julia AST from given command object cmd. This will wrap all the generated AST in a function command_main.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Comonicon.CodeGen.prettify-Tuple{Any}","page":"Code Generation","title":"Comonicon.CodeGen.prettify","text":"prettify(ex)\n\nPrettify given expression, remove all LineNumberNode and extra code blocks.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Comonicon.CodeGen.pushmaybe!-Tuple{Any,Any}","page":"Code Generation","title":"Comonicon.CodeGen.pushmaybe!","text":"push!(args, item)\n\nPush an item to the expression or list. Do nothing if the item is nothing.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Comonicon.CodeGen.read_arg-Tuple{Comonicon.CodeGen.ASTCtx}","page":"Code Generation","title":"Comonicon.CodeGen.read_arg","text":"read_arg(ctx::ASTCtx)\n\nReturn the expression that read the next argument from ARGS.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Comonicon.CodeGen.rm_lineinfo-Tuple{Any}","page":"Code Generation","title":"Comonicon.CodeGen.rm_lineinfo","text":"rm_lineinfo(ex)\n\nRemove LineNumberNode in a given expression\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Comonicon.CodeGen.xerror-Tuple{Any,String}","page":"Code Generation","title":"Comonicon.CodeGen.xerror","text":"xerror(cmd, msg)\n\nCreate an expression that contains error message, automatically merge interpolation expressions.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Comonicon.CodeGen.xmatch","page":"Code Generation","title":"Comonicon.CodeGen.xmatch","text":"xmatch(regexes, actions, str[, st = 1])\n\nGenerate a long ifelse expression that acts like a pattern matching expression that match given regex list and do the corresponding actions.\n\n\n\n\n\n","category":"function"},{"location":"#Comonicon","page":"Home","title":"Comonicon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"gith averminaluk ayh juldas mausan urdan","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Roger's magic book for command line interfaces.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest and most common way to use Comonicon is to use @cast and @main. Let's use a simple example to show how, the following example creates a command using @cast.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Comonicon\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you write this into a script file myscript.jl and execute it using","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia myscript.jl -h","category":"page"},{"location":"","page":"Home","title":"Home","text":"You will see the following in your terminal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  main\n\nNo documentation found.\nmycmd is a Function.\n# 1 method for generic function \"mycmd\":\n[1] mycmd(arg; option, flag) in Main at /Users/roger/.julia/dev/Comonicon/example/myscript.jl:2\n\nUsage\n\n  main [options...] [flags...] <arg>\n\nArgs\n\n  <arg>\n\nFlags\n\n  -f,--flag\n\n  -h, --help          print this help message\n\n  -V, --version       print version information\n\nOptions\n\n  --option <::Any>\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now let me explain what @main does here. In short it does the following things:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parse your expression and create a command line object\nuse this command line object to create an entry\ngenerate a Julia script to actually execute the command\ncache the generated Julia script into a file so it won't need to recompile your code again","category":"page"},{"location":"#Convention","page":"Home","title":"Convention","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"leaf command: leaf commands are the commands at the last of the CLI that takes arguments, options and flags, e.g the show command below","category":"page"},{"location":"","page":"Home","title":"Home","text":"node command: node commands are the commands at the middle or first of the CLI that contains sub-commands, e.g the remote command below","category":"page"},{"location":"","page":"Home","title":"Home","text":"git remote show origin","category":"page"},{"location":"","page":"Home","title":"Home","text":"arguments: arguments are command line arguments that required at the leaf command","category":"page"},{"location":"","page":"Home","title":"Home","text":"flags: flags are command line options that has no arguments, e.g --flag or -f (short flag).","category":"page"},{"location":"","page":"Home","title":"Home","text":"options: options are command line options that has arguments, e.g --name Sam or -n Sam, also --name=Sam or -nSam.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When used on function expressions, @cast and @main have the same convention on how they convert your expressions to commands, these are","category":"page"},{"location":"","page":"Home","title":"Home","text":"function arguments are parsed as command arguments:\nvalue will be converted automatically if arguments has type annotation\noptional arguments are allowed\nfunction keyword arguments are parsed as command flags or options:\nkeyword arguments must have default value\nkeyword arguments of type Bool can only have false as default value, which will be treated as flags that allow short flags.\nvalue will be converted automatically if keyword arguments has type annotation\nfunction doc string can use section names: Arguments, Options and Flags to annotate your CLI:\nshort options or short flags can be declared via -f, flag or -o, --option <name> (see example below)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"to be compatible with shell options, variable names with underscore _ will be automatically replaced with dash -.   As a result, the corresponding doc string should use dash - instead of _ as well, e.g kwargs name dash_dash will   be converted to --dash-dash option/flag in terminal, and its corresponding doc string should be - `--dash-dash`: <arg>.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example of function docstring","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"\"\"\nmy command line interface.\n\n# Arguments\n\n- `arg`: an argument\n\n# Options\n\n- `-o, --option`: an option that has short option.\n\n# Flags\n\n- `-f, --flag`: a flag that has short flag.\n\"\"\"\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will give a help message looks like below after execute this in myscript.jl via julia myscript.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n  main\n\nmy command line interface.\n\nUsage\n\n  main [options...] [flags...] <arg>\n\nArgs\n\n  <arg>                  an argument\n\nFlags\n\n  -f,--flag              a flag that has short flag.\n\n  -h, --help             print this help message\n\n  -V, --version          print version information\n\nOptions\n\n  -o, --option <name>","category":"page"},{"location":"#Create-a-CLI-project","page":"Home","title":"Create a CLI project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"However, to build better and faster CLI, you will want to build your CLI in a Julia package and deliver it to your users. This can be done via @cast.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@cast is similar to @main before functions, but it won't execute anything, but only create the command and register the command to a global variable CASTED_COMMANDS in the current module. And it will create NodeCommands before modules, and the sub-commands of the NodeCommand can be created via @cast inside the module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After you create the commands via @cast, you can declare an entry at the bottom of your module via @main. A simple example looks like the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"module Dummy\n\nusing Comonicon\n\n@cast mycmd1(arg; option=\"Sam\") = println(\"cmd1: arg=\", arg, \"option=\", option)\n@cast mycmd2(arg; option=\"Sam\") = println(\"cmd2: arg=\", arg, \"option=\", option)\n\nmodule Cmd3\n\nusing Comonicon\n\n@cast mycmd4(arg) = println(\"cmd4: arg=\", arg)\n\nend # module\n\n@main name=\"dummy\" version=v\"0.1.0\"\n\nend # module","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can find all created commands via following","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Dummy.CASTED_COMMANDS\nDict{String,Any} with 3 entries:\n  \"mycmd2\" => mycmd2 [options...] <arg>\n  \"main\"   => dummy v0.1.0\n  \"mycmd1\" => mycmd1 [options...] <arg>","category":"page"},{"location":"","page":"Home","title":"Home","text":"and you can execute the command via Dummy.command_main created by @main:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Dummy.command_main([\"-h\"])\n\n  dummy v0.1.0\n\n\n\nUsage\n\n  dummy <command>\n\nCommands\n\n  mycmd2 [options...] <arg>    No documentation found. Main.Dummy.mycmd2 is a\n                               # 1 method for generic function \"mycmd2\": [1]\n                               option) in Main.Dummy at REPL[2]:6\n\n  mycmd1 [options...] <arg>    No documentation found. Main.Dummy.mycmd1 is a\n                               # 1 method for generic function \"mycmd1\": [1]\n                               option) in Main.Dummy at REPL[2]:5\n\nFlags\n\n  -h, --help                   print this help message\n\n  -V, --version                print version information\n\n\n0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then you can create a build.jl file in your package deps folder to install this command to ~/.julia/bin when your user install your package. This will only need two line:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# build.jl\nusing Comonicon, Dummy\nComonicon.install(Dummy, \"dummy\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can turn on the keyword sysimg to true to compile a system image for the CLI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# build.jl\nusing Comonicon, Dummy\nComonicon.install(Dummy, \"dummy\"; sysimg=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is an example project IonCLI.jl you can take as a reference.","category":"page"},{"location":"build/#Build-and-Install-CLI","page":"Build and Install CLI","title":"Build and Install CLI","text":"","category":"section"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"You can use various way to build and install your CLI, this includes:","category":"page"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"use it as a script, and enable or disable compile cache via (Comonicon.disable_cache and Comonicon.enable_cache).\nbuild it as a package and install to ~/.julia/bin:\nuse compile=:min in Comonicon.install if you don't care about the speed\nuse sysimg=true in Comonicon.install if you care about both start up time and the speed","category":"page"},{"location":"build/#Reference","page":"Build and Install CLI","title":"Reference","text":"","category":"section"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"Modules = [Comonicon, Comonicon.PATH]","category":"page"},{"location":"build/#Comonicon.Comonicon","page":"Build and Install CLI","title":"Comonicon.Comonicon","text":"All the terminals are under my command. Comonicon is a CLI (Command Line Interface) generator that features light-weight dependency (optional to have zero dependency), fast start-up time and easy to use. See the website for more info.\n\n\n\n\n\n","category":"module"},{"location":"build/#Comonicon.PATH","page":"Build and Install CLI","title":"Comonicon.PATH","text":"path related functions.\n\n\n\n\n\n","category":"module"},{"location":"build/#Comonicon.PATH.default_exename-Tuple{}","page":"Build and Install CLI","title":"Comonicon.PATH.default_exename","text":"default_exename()\n\nDefault Julia executable name: joinpath(Sys.BINDIR, Base.julia_exename())\n\n\n\n\n\n","category":"method"},{"location":"build/#Comonicon.PATH.default_julia_bin-Tuple{}","page":"Build and Install CLI","title":"Comonicon.PATH.default_julia_bin","text":"default_julia_bin()\n\nReturn the default path to .julia/bin.\n\n\n\n\n\n","category":"method"},{"location":"build/#Comonicon.PATH.default_julia_fpath-Tuple{}","page":"Build and Install CLI","title":"Comonicon.PATH.default_julia_fpath","text":"default_julia_fpath()\n\nReturn the default path to .julia/completions\n\n\n\n\n\n","category":"method"},{"location":"build/#Comonicon.PATH.default_name-Tuple{Any}","page":"Build and Install CLI","title":"Comonicon.PATH.default_name","text":"default_name(x)\n\nReturn the lowercase of nameof(x) in String.\n\n\n\n\n\n","category":"method"},{"location":"build/#Comonicon.PATH.default_name-Tuple{String}","page":"Build and Install CLI","title":"Comonicon.PATH.default_name","text":"default_name(x)\n\nReturn the lowercase of a given package name. It will ignore the suffix if it ends with \".jl\".\n\n\n\n\n\n","category":"method"}]
}
