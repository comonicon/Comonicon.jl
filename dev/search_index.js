var documenterSearchIndex = {"docs":
[{"location":"project/#project","page":"Create a CLI project","title":"CLI Project","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"To build better, faster and more complicated CLI, you will want to build your CLI in a Julia package and deliver it to your users. I will introduce how to create a Comonicon CLI project in this chapter.","category":"page"},{"location":"project/#Create-a-Julia-Comonicon-project","page":"Create a CLI project","title":"Create a Julia Comonicon project","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"A Comonicon CLI project is first a Julia project, thus you should first create a Julia project. If you don't know what is a Julia project, please read about the Pkg section of creating packages. The minimal requirement of a Julia Comonicon project is the following structure","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"Demo\n├── LICENSE\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── src\n│   └── Demo.jl\n└── test\n    └── runtests.jl","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"usually it's more convenient to create a Julia project via IonCLI, after you install IonCLI, you can type the following command in your terminal","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"ion create Demo --template=comonicon","category":"page"},{"location":"project/#Use-@cast-to-define-multiple-commands","page":"Create a CLI project","title":"Use @cast to define multiple commands","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"In a large project, one might need to define multiple commands. This can be done via @cast.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"@cast","category":"page"},{"location":"project/#Comonicon.@cast","page":"Create a CLI project","title":"Comonicon.@cast","text":"@cast <function definition>\n@cast <module definition>\n\nDenote a Julia expression is a command. If the expression is a function definition, it will be parsed as a leaf command, if the expression is a module definition or module name, it will be parsed as a node command. This macro must be used with @main to create a multi-command CLI.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@cast function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\n\"product two numbers\"\n@cast function prod(x, y)\n    return\nend\n\n@main\n\n\n\n\n\n","category":"macro"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"@cast is similar to @main before functions, but it won't execute anything, but only create the command and register the command to a global variable CASTED_COMMANDS in the current module. And it will create NodeCommands before modules, and the sub-commands of the NodeCommand can be created via @cast inside the module.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"After you create the commands via @cast, you can declare an entry at the bottom of your module via @main. A simple example looks like the following","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"module Demo\n\nusing Comonicon\n\n@cast mycmd1(arg; option=\"Sam\") = println(\"cmd1: arg=\", arg, \"option=\", option)\n@cast mycmd2(arg; option=\"Sam\") = println(\"cmd2: arg=\", arg, \"option=\", option)\n\n\"\"\"\na module\n\"\"\"\nmodule Cmd3\n\nusing Comonicon\n\n@cast mycmd4(arg) = println(\"cmd4: arg=\", arg)\n\nend # module\n\n@cast Cmd3\n\n\"\"\"\nmy demo Comonicon CLI project.\n\"\"\"\n@main\n\nend # module","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can find all created commands via following","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"julia> Demo.CASTED_COMMANDS\nDict{String,Any} with 4 entries:\n  \"mycmd2\" => mycmd2 [options] <arg>\n  \"cmd3\"   => cmd3 <command>\n  \"main\"   => demo v0.1.0\n  \"mycmd1\" => mycmd1 [options] <arg>","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"and you can execute the command via Demo.command_main created by @main:","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"(Image: project-demo)","category":"page"},{"location":"project/#Setup-the-build.jl","page":"Create a CLI project","title":"Setup the build.jl","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"Then you can create a build.jl file in your package deps folder to install this command to ~/.julia/bin when your user install your package. This will only need one line:","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"# build.jl\nusing Demo; Demo.comonicon_install()","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"To learn about how to use it, you can type","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"julia --project deps/build.jl -h","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"which will print the following help message:","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"(Image: build-help)","category":"page"},{"location":"project/#Install-the-CLI","page":"Create a CLI project","title":"Install the CLI","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can now install the CLI by building the package either in REPL via ]build or use IonCLI in terminal via","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"ion build # in Demo folder","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"This will install this command to ~/.julia/bin directory by default, if you have put this directory in your PATH then you will be able to use the command demo directory in your terminal, e.g","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"demo -h","category":"page"},{"location":"project/#Enable-System-Image","page":"Create a CLI project","title":"Enable System Image","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"Some CLI projects are quite complicated thus the startup latency is still quite huge even the package module is precompiled. In this case, one will want to use a system image to reduce the startup latency.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can enable to the system image build by specifying [sysimg] field in your Comonicon configuration file Comonicon.toml (or JuliaComonicon.toml).","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"name = \"demo\"\n\n[install]\ncompletion = true\nquiet = false\noptimize = 2\n\n[sysimg]","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can also specify more detailed system image compilation options, e.g","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[sysimg]\nincremental=false\nfilter_stdlibs=true","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can find more references for these options in PackageCompiler#create_sysimage.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"However, you may still find it being slow, you can further reduce the latency by adding an execution file to record precompilation statements.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[sysimg.precompile]\nexecution_file = [\"deps/precompile.jl\"]","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"or you can manually specify these precompile statements via","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[sysimg.precompile]\nstatements_file = [\"deps/statements.jl\"]","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"you can learn more about how to create precompilation statements via SnoopCompile and create a userimg.jl as the precompilation statements.","category":"page"},{"location":"project/#Enable-Application-Build","page":"Create a CLI project","title":"Enable Application Build","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can build a standalone application similar to building a system image as well, e.g","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[application]\nincremental=true\nfilter_stdlibs=false\n\n[application.precompile]\nstatements_file = [\"deps/statements.jl\"]","category":"page"},{"location":"project/#Further-Reference","page":"Create a CLI project","title":"Further Reference","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"The CLI we just used to create this project serves as the best practice for Comonicon, you can take it as a reference: IonCLI.jl.","category":"page"},{"location":"parse/#Parse","page":"Command Parsing","title":"Parse","text":"","category":"section"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"This is the frontend @cast and @main of Comonicon.","category":"page"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"The @main command will use generate the following functions in the module:","category":"page"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"the entry function for CLI command_main.\ncomonicon_install: for command build and installation.\ncomonicon_install_path: for path build and installation.\njulia_main: for building standalone applications.","category":"page"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"And a registry constant CASTED_COMMANDS in the module, one can find the original Comonicon AST by indexing CASTED_COMMANDS by your command name.","category":"page"},{"location":"parse/#References","page":"Command Parsing","title":"References","text":"","category":"section"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"Modules = [Comonicon]","category":"page"},{"location":"parse/#Comonicon.Comonicon","page":"Command Parsing","title":"Comonicon.Comonicon","text":"All the terminals are under my command. Comonicon is a CLI (Command Line Interface) generator that features light-weight dependency (optional to have zero dependency), fast start-up time and easy to use. See the website for more info.\n\n\n\n\n\n","category":"module"},{"location":"parse/#Comonicon.CommandError","page":"Command Parsing","title":"Comonicon.CommandError","text":"struct CommandError <: CommandException\n\nException type for general CLI compatible errors thrown by cmd_error.\n\n\n\n\n\n","category":"type"},{"location":"parse/#Comonicon.CommandException","page":"Command Parsing","title":"Comonicon.CommandException","text":"CommandException <: Exception\n\nAbstract type for command exceptions. All command exceptions should contain an exitcode field.\n\n\n\n\n\n","category":"type"},{"location":"parse/#Comonicon.CommandExit","page":"Command Parsing","title":"Comonicon.CommandExit","text":"struct CommandExit <: CommandException\n\nException type for cmd_exit.\n\n\n\n\n\n","category":"type"},{"location":"parse/#Comonicon.cmd_error","page":"Command Parsing","title":"Comonicon.cmd_error","text":"cmd_error(msg::String, code::Int = 1)\n\nThrow a CommandError with message msg and return code code. This is preferred as exception handle when writing a CLI compatible Julia program.\n\nWhen the program is running in normal Julia execution the error will print as normal Julia exception with stacktrace.\n\nWhen the progrm is running from a CLI entry, the exception is printed as standard CLI exceptions with exit code (default is 1). Then the corresponding help message is printed.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.cmd_exit","page":"Command Parsing","title":"Comonicon.cmd_exit","text":"cmd_exit(code::Int = 0)\n\nExit the CLI program with code. This method is preferred over exit to make sure the program won't exit directly without handling the exception.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.default_name-Tuple{String}","page":"Command Parsing","title":"Comonicon.default_name","text":"default_name(x::String)\n\nReturn the lowercase of a given package name. It will ignore the suffix if it ends with \".jl\".\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.get_version-Tuple{Module}","page":"Command Parsing","title":"Comonicon.get_version","text":"get_version(m::Module)\n\nGet the version of a given module. It will try to find the version of Project.toml if the given module is a project module. If fails, it returns v\"0.0.0\".\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.parse_kwargs-Tuple{ExproniconLite.JLFunction}","page":"Command Parsing","title":"Comonicon.parse_kwargs","text":"parse_kwargs(fn::JLFunction) -> flags, options\n\nParse the keyword arguments of function expression fn into intermediate Julia CLI objects JLFlag and JLOption.\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.rm_format","page":"Command Parsing","title":"Comonicon.rm_format","text":"rm_format(md)\n\nRemove Markdown DOM and flatten to strings.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.set_cmd!","page":"Command Parsing","title":"Comonicon.set_cmd!","text":"set_cmd!(cmds::Dict, cmd)\n\nregister cmd in the command registry cmds, which usually is a constant CASTED_COMMANDS under given module.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.write_cmd-Tuple{Any, Comonicon.AST.Entry}","page":"Command Parsing","title":"Comonicon.write_cmd","text":"write_cmd(filename, cmd::Entry)\n\nWrite a command to filename.\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.@cast-Tuple{Any}","page":"Command Parsing","title":"Comonicon.@cast","text":"@cast <function definition>\n@cast <module definition>\n\nDenote a Julia expression is a command. If the expression is a function definition, it will be parsed as a leaf command, if the expression is a module definition or module name, it will be parsed as a node command. This macro must be used with @main to create a multi-command CLI.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@cast function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\n\"product two numbers\"\n@cast function prod(x, y)\n    return\nend\n\n@main\n\n\n\n\n\n","category":"macro"},{"location":"parse/#Comonicon.@lazyload-Tuple{Any, Any}","page":"Command Parsing","title":"Comonicon.@lazyload","text":"@lazyload expr @cast <valid castable expr>\n\nEvaluate expr if command f is called. This is useful for reducing the latency of scripts that has subcmds depend on plotting, serialization etc.\n\nPlease see @cast for valid expression specifications.\n\nwarning: Warning\nThis macro only works at top-level command and thus can only be used in Main and only works in scripts. Using this macro in any other module or a project module will not work.\n\n\n\n\n\n","category":"macro"},{"location":"parse/#Comonicon.@main-Tuple{}","page":"Command Parsing","title":"Comonicon.@main","text":"@main\n@main <function definition>\n\nMain entry of the CLI application.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@main function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\nCLI Definitions and Julia Syntax Mapping\n\npositional arguments normal inputs, these are mapped as Julia function arguments, e.g\n\nsum 1 2\n\nsum is the command, and 1, 2 are positional arguments.\n\noptions arguments with syntax --<name>=<value> or --<name> <value>, these are mapped as Julia keyword arguments, e.g\n\nsum --precision=float32 1 2\n\n--precision is the option of command sum and has value float32.\n\nshort options arguments with syntax -<letter>=<value> or -<letter><value> or --<letter> <value>, the letter is usually the first character of a normal option, e.g\n\nsum -pfloat32 1 2\n\n-p is the same as --precision, but in short hand, this is enabled by writing corresponding docstring (see the next section on docstring syntax).\n\nflags like options, but without any value, e.g --<name>, this is mapped to a special type of keyword argument that is of type Bool and has default value false, e.g\n\nsum --fastmath\n\nshort flags flags with syntax -<letter>, the letter should be the first character of the corresponding normal flag, e.g\n\nsum -f\n\nDoc String Syntax\n\nEach different kind of inputs must have a different level-1 section (markdown syntax #<section name>).\n\nThe docstring must have section name:\n\n#Args or #Arguments to declare the documentation   of positional arguments.\n#Options to declare the documentation of options.\n#Flags to declare the documentation of flags.\n\nExamples\n\nThe simplest usage is creating the following commands\n\n\"\"\"\nan example command\n\n# Args\n\n- `x`: first argument\n- `y`: second argument\n- `z`: last argument\n\n# Flags\n\n- `-f, --flag`: a flag, optionally can be a short flag.\n\n# Options\n\n- `-o, --option=<int>`: an option, optionally can be short option.\n\n\"\"\"\n@cast function mycommand(x, y, z; flag::Bool=false, option::Int=2)\n    # some implementation\n    return\nend\n\n@cast function myothercommand(xs...)\n    # another command with variatic arguments\n    return\nend\n\n\"\"\"\nMy main command.\n\"\"\"\n@main # declare the entry\n\nthis can be used in command line as mycommand 1 2 3 --flag, you can also just type -h to check the detailed help info.\n\nThe command line documentation will be generated automatically from your Julia docstring.\n\nIf you have deeper hierachy of commands, you can also put @cast on a Julia module.\n\nusing Comonicon\n@cast module NodeCommand\n\nusing Comonicon\n\n@cast module NodeSubCommand\nusing Comonicon\n@cast bar(x) = println(\"bar $x\")\nend\n@cast foo(x) = println(\"foo $x\")\n@main\nend\n\nNodeCommand.command_main()\n\n\n\n\n\n","category":"macro"},{"location":"types/#Command-Types","page":"Command Types","title":"Command Types","text":"","category":"section"},{"location":"types/","page":"Command Types","title":"Command Types","text":"The frontend @main and @cast restrict a lot features to make the package interface as simple as possible. However, if you want to customize the behaviour, you can also create command objects directly via the interfaces at this level, which are all in Comonicon.AST.","category":"page"},{"location":"types/#References","page":"Command Types","title":"References","text":"","category":"section"},{"location":"types/","page":"Command Types","title":"Command Types","text":"Modules = [Comonicon.AST]","category":"page"},{"location":"types/#Comonicon.AST.Argument","page":"Command Types","title":"Comonicon.AST.Argument","text":"struct Argument <: ComoniconExpr\n\ntype for positional argument of a command.\n\nFields\n\nname::String: name of the argument.\ntype: type of the argument, default Any.\nvararg::Bool: if the argument is a variant argument, default false.\nrequire::Bool: if the argument is required, default true.\ndefault::Maybe{String}: the default value of this argument if argument is not required (optional), default nothing.\ndescription::Description: the description of this argument, default Description().\nline::Maybe{LineNumberNode}: the line number of this argument, default is nothing.\n\nConstructors\n\nArgument(fields_above...)\nArgument(;fields_above...)\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.Color","page":"Command Types","title":"Comonicon.AST.Color","text":"mutable struct Color\n\nColor configuration.\n\nFields\n\nname::Symbol: command name color.\nargs::Symbol: command args color.\ndash::Symbol: command flag/option color.\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.ComoniconExpr","page":"Command Types","title":"Comonicon.AST.ComoniconExpr","text":"abstract type ComoniconExpr end\n\nAbstract type for Comonicon CLI expression.\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.Description","page":"Command Types","title":"Comonicon.AST.Description","text":"struct Description <: ComoniconExpr\n\ntype for description of a command object.\n\nFields\n\nbrief::String: brief introduction of the command,   will be printed as the first sentence   of the whole description as well as brief intro in   upper level help info.\ncontent::String: long introduction of the command.\n\nConstructors\n\nDescription(;brief=\"\", content=\"\")\nDescription(brief)\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.Entry","page":"Command Types","title":"Comonicon.AST.Entry","text":"struct Entry <: ComoniconExpr\n\nTop-level entry of the CLI.\n\nFields\n\nroot::Union{NodeCommand,LeafCommand}: the entry command.\nversion::Maybe{VersionNumber}: version number of the command.\nline::Maybe{LineNumberNode}: line number of the original Julia program.\n\nConstructors\n\nEntry(fields_above...)\nEntry(;fields_above...)\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.Flag","page":"Command Types","title":"Comonicon.AST.Flag","text":"struct Flag <: ComoniconExpr\n\nType for flag in CLI, e.g --flag or -f.\n\nFields\n\nsym: the symbol in Julia programs.\nname::String: name of the flag, default is the same as sym but will replace _ with -.\nshort::Bool: if this flag support short flag syntax e.g -f, default is false.\ndescription::Description: description of this flag, default is Description().\nline::Maybe{LineNumberNode}: the line number of this flag object in original Julia program.\n\nConstructors\n\nFlag(fields_above...)\nFlag(;fields_above...)\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.LeafCommand","page":"Command Types","title":"Comonicon.AST.LeafCommand","text":"struct LeafCommand <: ComoniconExpr\n\nType for a leaf command in CLI. A leaf command is the command that actually execute the program e.g\n\nmain-cmd node-cmd leaf-cmd 1 2 3\n\nFields\n\nfn: a Julia callable that executes the command.\nname::String: name of the command.\nargs::Vector{Argument}: list of CLI arguments, see Argument, default is Argument[].\nnrequire::Int: number of required arguments, default is the number of require==true arugments in args.\nvararg::Maybe{Argument}: variant argument, default is nothing.\nflags::Dict{String, Flag}: map between flag name and flag object, see Flag, default is the empty collection.\noptions::Dict{String, Option}: map between option name and option object, see Option, default is the empty collection.\ndescription::Description: description of the leaf command, default is Description().\nline::Maybe{LineNumberNode}: line number of the leaf command in original Julia program.\n\nConstructors\n\nLeafCommand(fields_above...)\nLeafCommand(;fields_above...)\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.NodeCommand","page":"Command Types","title":"Comonicon.AST.NodeCommand","text":"struct NodeCommand <: ComoniconExpr\n\nType for node command in a CLI, these command are only used to dispatch the actual command in CLI, and must have sub-command, e.g\n\nmain-cmd node-cmd leaf-cmd 1 2 3\n\nFields\n\nname::String: name of the command.\nsubcmds::Dict{String, Any}: sub-commands of the node command,   this is a name=>command dict, the command should be either   NodeCommand or LeafCommand.\ndescription::Description: description of this node command, default is Description().\nline::Maybe{LineNumberNode}: line number of the node command in its original Julia program, default is nothing.\n\nConstructors\n\nNodeCommand(fields_above...)\nNodeCommand(;fields_above...)\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.Option","page":"Command Types","title":"Comonicon.AST.Option","text":"struct Option <: ComoniconExpr\n\ntype for options, e.g --option=<value> or -o<value>.\n\nFields\n\nsym::Symbol: symbol of the option in Julia program.\nname::String: name of the option in shell, by default   this is the same as sym but will replace _ with -.\nhint::Maybe{String}: hint message of this option, default is nothing.\nrequire::Bool: if this option is required, default is false.\ntype: type of the option value, default is Any.\nshort::Bool: if the option support short option syntax (-o<value> syntax), default is false.\ndescription::Description: description of this option, default is Description().\nline::Maybe{LineNumberNode}: line number of this option in Julia scripts.\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.Terminal","page":"Command Types","title":"Comonicon.AST.Terminal","text":"mutable struct Terminal\n\nConfigurations for terminal printing.\n\nFields\n\nwidth::Int: width of the terminal.\nleft::Int: left column max width.\nright::Int: right column max width.\ncolor:Color: color configurations, see Color.\nindent::Indent: indent configuration, see Indent.\nbrief::Bool: print the brief intro or not.\n\n\n\n\n\n","category":"type"},{"location":"types/#Comonicon.AST.print_cmd","page":"Command Types","title":"Comonicon.AST.print_cmd","text":"print_cmd([io::IO], cmd, [terminal::Terminal])\n\nPrint the command object in terminal.\n\nArguments\n\nio::IO: an IO object, default is stdout.\ncmd: a command object, can be Entry, NodeCommand, LeafCommand.\nterminal::Terminal: a Terminal object, contains   the printing and terminal configuration. See also Terminal.\n\n\n\n\n\n","category":"function"},{"location":"types/#Comonicon.AST.splitlines","page":"Command Types","title":"Comonicon.AST.splitlines","text":"splitlines(s, width = 80)\n\nSplit a given string into lines of width 80 characters.\n\n\n\n\n\n","category":"function"},{"location":"types/#Comonicon.AST.splittext-Tuple{String}","page":"Command Types","title":"Comonicon.AST.splittext","text":"splittext(s)\n\nSplit the text in string s into an array, but keep all the separators attached to the preceding word.\n\nnote: Note\nthis is copied from Luxor/text.jl\n\n\n\n\n\n","category":"method"},{"location":"conventions/#Syntax-and-Conventions","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"","category":"section"},{"location":"conventions/#Basics","page":"Syntax & Conventions","title":"Basics","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"leaf command: leaf commands are the commands at the last of the CLI that takes arguments, options and flags, e.g the show command below","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"node command: node commands are the commands at the middle or first of the CLI that contains sub-commands, e.g the remote command below","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"git remote show origin","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"arguments: arguments are command line arguments that required at the leaf command","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"flags: flags are command line options that has no arguments, e.g --flag or -f (short flag).","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"options: options are command line options that has arguments, e.g --name Sam or -n Sam, also --name=Sam or -nSam.","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"When used on function expressions, @cast and @main have the same convention on how they convert your expressions to commands, these are","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"function arguments are parsed as command arguments:\nvalue will be converted automatically if arguments has type annotation\noptional arguments are allowed\nfunction keyword arguments are parsed as command flags or options:\nkeyword arguments must have default value\nkeyword arguments of type Bool can only have false as default value, which will be treated as flags that allow short flags.\nvalue will be converted automatically if keyword arguments has type annotation\nfunction doc string can use section names: Arguments, Options and Flags to annotate your CLI:\nshort options or short flags can be declared via -f, flag or -o, --option <name> (see example below)","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"note: Note\nto be compatible with shell options, variable names with underscore _ will be automatically replaced with dash -.   As a result, the corresponding doc string should use dash - instead of _ as well, e.g kwargs name dash_dash will be converted to --dash-dash option/flag in terminal, and its corresponding doc string should be - `--dash-dash`: <arg>.","category":"page"},{"location":"conventions/#Help-and-Version","page":"Syntax & Conventions","title":"Help and Version","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"There are two flags are always generated and always have highest priority, they are -h,--help and --version. The version is automatically read from the corresponding project's Project.toml if it's not found then it's set to 0.0.0.","category":"page"},{"location":"conventions/#Doc-String-Syntax","page":"Syntax & Conventions","title":"Doc String Syntax","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"the docstring of each @cast or @main annotated object have a few special section. The function or module signature is ignored for generating CLI help page, ","category":"page"},{"location":"conventions/#Description","page":"Syntax & Conventions","title":"Description","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"The description of the command is seperated as brief and detailed description. The special sections are organized as following:","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"The brief description is the first paragraph of the docstring.\nThe long detailed description can be specified using #Intro or #Introduction section.","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"for example","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"\"\"\"\n    command(args1, args2, args3, args4)\n\nthe brief description of the command.\n\n# Intro\n\nthe long description of the command,\nasdmwds dasklsam xasdklqm dasdm, qwdjiolkasjdsa\ndasklmdas weqwlkjmdas kljnsadlksad qwlkdnasd\ndasklmdlqwoi, dasdasklmd qw,asd. dasdjklnmldqw.\n\"\"\"","category":"page"},{"location":"conventions/#Arguments","page":"Syntax & Conventions","title":"Arguments","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"The argument description can be specified using #Args or #Arguments section. The syntax must be","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"- `<arg name>`: <description of the argument>","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"for example","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"\"\"\"\n    command(args1, args2, args3, args4)\n\nthe brief description of the command.\n\n# Intro\n\nthe long description of the command,\nasdmwds dasklsam xasdklqm dasdm, qwdjiolkasjdsa\ndasklmdas weqwlkjmdas kljnsadlksad qwlkdnasd\ndasklmdlqwoi, dasdasklmd qw,asd. dasdjklnmldqw.\n\n# Args\n\n- `arg1`: argument 1.\n- `arg2`: argument 2.\n- `arg3`: argument 3.\n- `arg4`: argument 4.\n\"\"\"","category":"page"},{"location":"conventions/#Options","page":"Syntax & Conventions","title":"Options","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"the options can be specified in #Options section, the option must have a prefix --, and optionally have -<first letter> to specify its short option. All underscore _ in the option name will be converted to a dash - for option names, for example.","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"The value string after = (e.g -s=<value>) can give user specified hint or the default hint will be the default value's Julia expression.","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"# Options\n\n- `--short, -s`: short option using default hint.\n- `--short-space, -s <value>`: short option using given hint.\n- `--short-assign, -s=<value>`: short option using given hint.\n- `--long`: long option using default hint.\n- `--long-space <value>`: long option using given hint.\n- `--long-assign=<value>`: long option using given hint.\n- `--short_underscore, -s <value>`: short option with underscore.","category":"page"},{"location":"conventions/#Flags","page":"Syntax & Conventions","title":"Flags","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"the flags can be specified using #Flags section, the rest are similar to #Options except there are no value hints.","category":"page"},{"location":"conventions/#Special-Arugment/Options-Types","page":"Syntax & Conventions","title":"Special Arugment/Options Types","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"there are a few special argument/option types defined to generate special shell completions.","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"Modules = [Comonicon.Arg]","category":"page"},{"location":"conventions/#Comonicon.Arg.ArgType","page":"Syntax & Conventions","title":"Comonicon.Arg.ArgType","text":"abstract type ArgType\n\nAbstract type for special CLI arguments. These types are useful for generating shell autocompletions and argument checks. All the ArgType should implement a corresponding Base.tryparse method, otherwise it will fallback to passing the raw string as the content field.\n\n\n\n\n\n","category":"type"},{"location":"conventions/#Comonicon.Arg.DirName","page":"Syntax & Conventions","title":"Comonicon.Arg.DirName","text":"struct DirName <: ArgType\nDirName(content)\n\nA DirName object denotes a directory name as CLI input.\n\n\n\n\n\n","category":"type"},{"location":"conventions/#Comonicon.Arg.FileName","page":"Syntax & Conventions","title":"Comonicon.Arg.FileName","text":"struct FileName <: ArgType\nFileName(content)\n\nA FileName object denotes a file name as CLI input.\n\n\n\n\n\n","category":"type"},{"location":"conventions/#Comonicon.Arg.Path","page":"Syntax & Conventions","title":"Comonicon.Arg.Path","text":"struct Path <: ArgType\nPath(content)\n\nA Path object denotes a path as CLI input.\n\n\n\n\n\n","category":"type"},{"location":"conventions/#Comonicon.Arg.Prefix","page":"Syntax & Conventions","title":"Comonicon.Arg.Prefix","text":"struct Prefix{name} <: ArgType\nPrefix{name}(content)\n\nDenotes strings with prefix name as CLI input, e.g data-xxx\n\n\n\n\n\n","category":"type"},{"location":"conventions/#Comonicon.Arg.Suffix","page":"Syntax & Conventions","title":"Comonicon.Arg.Suffix","text":"struct Suffix{name} <: ArgType\nSuffix{name}(content)\n\nDenotes strings with suffix name as CLI input, e.g xxxxx.jl.\n\n\n\n\n\n","category":"type"},{"location":"conventions/#Comonicon.Arg.UserName","page":"Syntax & Conventions","title":"Comonicon.Arg.UserName","text":"struct UserName <: ArgType\nUserName(content)\n\nA UserName object denotes a Linux/MacOS user name as CLI input.\n\n\n\n\n\n","category":"type"},{"location":"conventions/#Comonicon.Arg.@Prefix_str-Tuple{String}","page":"Syntax & Conventions","title":"Comonicon.Arg.@Prefix_str","text":"macro Prefix_str\nPrefix\"<name>\"\n\nSyntax sugar for creating a prefix type, e.g Predix\"data\" is the same as Prefix{:data}.\n\n\n\n\n\n","category":"macro"},{"location":"conventions/#Comonicon.Arg.@Suffix_str-Tuple{String}","page":"Syntax & Conventions","title":"Comonicon.Arg.@Suffix_str","text":"macro Suffix_str\nSuffix\"<name>\"\n\nSyntax sugar for creating a suffix type, e.g Suffix\"data\" is the same as Suffix{:data}.\n\n\n\n\n\n","category":"macro"},{"location":"conventions/#Dash-Seperator","page":"Syntax & Conventions","title":"Dash Seperator","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"Dash seperator -- is useful when the CLI program contains scripts that accepts command line inputs, e.g a custom command run that execute Julia script","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"run --flag -- script.jl a b c","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"one will need to seperate the input of run and script.jl for disambiguity sometimes,then the dash seperator comes useful for this case.","category":"page"},{"location":"conventions/#Plugins","page":"Syntax & Conventions","title":"Plugins","text":"","category":"section"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"Most complicated CLIs support plugins, this is acheived by checking if there is a command line executable with the following name pattern","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"<main command name>-<plugin name>","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"for example, git have plugin program called git-shell and can be called as git shell, this is by default turned off, but one can enable this feature by setting the following in (Julia)Comonicon.toml","category":"page"},{"location":"conventions/","page":"Syntax & Conventions","title":"Syntax & Conventions","text":"[command]\nplugin=true","category":"page"},{"location":"configurations/#Configurations","page":"Command Configuration","title":"Configurations","text":"","category":"section"},{"location":"configurations/","page":"Command Configuration","title":"Command Configuration","text":"Configurations can be defined via a TOML file, it should be named as either Comonicon.toml or JuliaComonicon.toml under a Julia project project root directory.","category":"page"},{"location":"configurations/#References","page":"Command Configuration","title":"References","text":"","category":"section"},{"location":"configurations/","page":"Command Configuration","title":"Command Configuration","text":"Modules = [Comonicon.Configs]","category":"page"},{"location":"configurations/#Comonicon.Configs.Application","page":"Command Configuration","title":"Comonicon.Configs.Application","text":"Application\n\nApplication build configurations.\n\nKeywords\n\npath: application build path, default is \"build\".\nincremental: set to true to build incrementally, default is true.\nfilter_stdlibs: set to true to filter out unused stdlibs, default is false.\ncpu_target: cpu target to build, default is PackageCompiler.default_app_cpu_target().\nprecompile: precompile configurations, see Precompile, default is Precompile().\nc_driver_program: driver program.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Configs.Command","page":"Command Configuration","title":"Comonicon.Configs.Command","text":"Command\n\nConfigs for Command execution.\n\nKeywords\n\ncolor: whether print with color in help page, default is true.\nstatic: whether genrate help info at compile time,   the format won't be adaptive to displaysize anymore,   if true, default is true.\nwidth: if static=true, width is used to set the static size of expected terminal.\ndash: whether parse -- seperator, default is true.\nplugin: parse <main CLI name>-<plugin> for CLI plugin, default is false.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Configs.Comonicon","page":"Command Configuration","title":"Comonicon.Configs.Comonicon","text":"Comonicon\n\nBuild configurations for Comonicon. One can set this option via Comonicon.toml under the root path of a Julia project directory and read in using read_configs.\n\nKeywords\n\nname: required, the name of CLI file to install.\ncommand: configs for command parsing.\ninstall: installation options, see also Install.\nsysimg: system image build options, see also SysImg.\ndownload: download options, see also Download.\napplication: application build options, see also Application.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Configs.Download","page":"Command Configuration","title":"Comonicon.Configs.Download","text":"Download\n\nDownload information.\n\nKeywords\n\nhost: where are the tarballs hosted, default is \"github.com\"\nuser: required, user name on the host.\nrepo: required, repo name on the host.\n\nnote: Note\nCurrently this only supports github, and this is considered experimental.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Configs.Install","page":"Command Configuration","title":"Comonicon.Configs.Install","text":"Install\n\nInstallation configurations.\n\nKeywords\n\npath: installation path.\ncompletion: set to true to install shell auto-completion scripts.\nquiet: print logs or not, default is false.\ncompile: julia compiler option for CLIs if not built as standalone application, default is \"min\".\noptimize: julia compiler option for CLIs if not built as standalone application, default is 2.\nnthreads: julia compiler option for CLIs if not built as standalone application, default is 1.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Configs.Precompile","page":"Command Configuration","title":"Comonicon.Configs.Precompile","text":"Precompile\n\nPrecompilation files for PackageCompiler.\n\nKeywords\n\nexecution_file: precompile execution file.\nstatements_file: precompile statements file.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Configs.SysImg","page":"Command Configuration","title":"Comonicon.Configs.SysImg","text":"SysImg\n\nSystem image build configurations.\n\nKeywords\n\npath: system image path to generate into, default is \"deps/lib\".\nincremental: set to true to build incrementally, default is true.\nfilter_stdlibs: set to true to filter out unused stdlibs, default is false.\ncpu_target: cpu target to build, default is PackageCompiler.default_app_cpu_target().\nprecompile: precompile configurations, see Precompile, default is Precompile().\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Configs.find_comonicon_toml","page":"Command Configuration","title":"Comonicon.Configs.find_comonicon_toml","text":"find_comonicon_toml(path::String, files=[\"Comonicon.toml\", \"JuliaComonicon.toml\"])\n\nFind Comonicon.toml or JuliaComonicon.toml in given path.\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Comonicon.Configs.read_options-Tuple{Union{Module, String}}","page":"Command Configuration","title":"Comonicon.Configs.read_options","text":"read_options(comonicon; kwargs...)\n\nRead in Comonicon build options. The argument comonicon can be:\n\na module of a Comonicon CLI project.\na path to a Comonicon CLI project that contains either JuliaComonicon.toml or Comonicon.toml.\na path to a Comonicon CLI build configuration file named either JuliaComonicon.toml or Comonicon.toml.\n\nIn some cases, you might want to change the configuration written in the TOML file temporarily, e.g for writing build tests etc. In this case, you can modify the configuration using corresponding keyword arguments.\n\nkeyword arguments of Application and SysImg are the same, thus keys like filter_stdlibs are considered ambiguous in read_options, but you can specifiy them by specifiy the specific Application or SysImg object, e.g\n\nread_options(MyCLI; sysimg=SysImg(filter_stdlibs=false))\n\nSee also Comonicon, Install, SysImg, Application, Download, Precompile.\n\n\n\n\n\n","category":"method"},{"location":"configurations/#Comonicon.Configs.read_toml-Tuple{Module}","page":"Command Configuration","title":"Comonicon.Configs.read_toml","text":"read_toml(mod::Module)\n\nRead Comonicon.toml or JuliaComonicon.toml in given module's project path.\n\n\n\n\n\n","category":"method"},{"location":"configurations/#Comonicon.Configs.read_toml-Tuple{String}","page":"Command Configuration","title":"Comonicon.Configs.read_toml","text":"read_toml(path::String)\n\nRead Comonicon.toml or JuliaComonicon.toml in given path.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Code-Generation","page":"Code Generation","title":"Code Generation","text":"","category":"section"},{"location":"codegen/","page":"Code Generation","title":"Code Generation","text":"This is the backend of Comonicon. Currently it can only generates a Julia AST.","category":"page"},{"location":"codegen/#References","page":"Code Generation","title":"References","text":"","category":"section"},{"location":"codegen/","page":"Code Generation","title":"Code Generation","text":"Modules = [Comonicon.JuliaExpr]","category":"page"},{"location":"codegen/#Comonicon.JuliaExpr.emit","page":"Code Generation","title":"Comonicon.JuliaExpr.emit","text":"emit(cmd::Entry[, ptr::Int=1])\n\nEmit Expr from a Entry.\n\n\n\n\n\n","category":"function"},{"location":"#Comonicon","page":"Home","title":"Comonicon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"gith averminaluk ayh juldas mausan urdan","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Roger's magic book for command line interfaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Comonicon","category":"page"},{"location":"#Comonicon","page":"Home","title":"Comonicon","text":"All the terminals are under my command. Comonicon is a CLI (Command Line Interface) generator that features light-weight dependency (optional to have zero dependency), fast start-up time and easy to use. See the website for more info.\n\n\n\n\n\n","category":"module"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest and most common way to use Comonicon is to use @cast and @main.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@main","category":"page"},{"location":"#Comonicon.@main","page":"Home","title":"Comonicon.@main","text":"@main\n@main <function definition>\n\nMain entry of the CLI application.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@main function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\nCLI Definitions and Julia Syntax Mapping\n\npositional arguments normal inputs, these are mapped as Julia function arguments, e.g\n\nsum 1 2\n\nsum is the command, and 1, 2 are positional arguments.\n\noptions arguments with syntax --<name>=<value> or --<name> <value>, these are mapped as Julia keyword arguments, e.g\n\nsum --precision=float32 1 2\n\n--precision is the option of command sum and has value float32.\n\nshort options arguments with syntax -<letter>=<value> or -<letter><value> or --<letter> <value>, the letter is usually the first character of a normal option, e.g\n\nsum -pfloat32 1 2\n\n-p is the same as --precision, but in short hand, this is enabled by writing corresponding docstring (see the next section on docstring syntax).\n\nflags like options, but without any value, e.g --<name>, this is mapped to a special type of keyword argument that is of type Bool and has default value false, e.g\n\nsum --fastmath\n\nshort flags flags with syntax -<letter>, the letter should be the first character of the corresponding normal flag, e.g\n\nsum -f\n\nDoc String Syntax\n\nEach different kind of inputs must have a different level-1 section (markdown syntax #<section name>).\n\nThe docstring must have section name:\n\n#Args or #Arguments to declare the documentation   of positional arguments.\n#Options to declare the documentation of options.\n#Flags to declare the documentation of flags.\n\nExamples\n\nThe simplest usage is creating the following commands\n\n\"\"\"\nan example command\n\n# Args\n\n- `x`: first argument\n- `y`: second argument\n- `z`: last argument\n\n# Flags\n\n- `-f, --flag`: a flag, optionally can be a short flag.\n\n# Options\n\n- `-o, --option=<int>`: an option, optionally can be short option.\n\n\"\"\"\n@cast function mycommand(x, y, z; flag::Bool=false, option::Int=2)\n    # some implementation\n    return\nend\n\n@cast function myothercommand(xs...)\n    # another command with variatic arguments\n    return\nend\n\n\"\"\"\nMy main command.\n\"\"\"\n@main # declare the entry\n\nthis can be used in command line as mycommand 1 2 3 --flag, you can also just type -h to check the detailed help info.\n\nThe command line documentation will be generated automatically from your Julia docstring.\n\nIf you have deeper hierachy of commands, you can also put @cast on a Julia module.\n\nusing Comonicon\n@cast module NodeCommand\n\nusing Comonicon\n\n@cast module NodeSubCommand\nusing Comonicon\n@cast bar(x) = println(\"bar $x\")\nend\n@cast foo(x) = println(\"foo $x\")\n@main\nend\n\nNodeCommand.command_main()\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"Let's use a simple example to show how, the following example creates a command using @main.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Comonicon\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you write this into a script file myscript.jl and execute it using","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia myscript.jl -h","category":"page"},{"location":"","page":"Home","title":"Home","text":"You will see the following in your terminal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: myscript-help)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to add some description to your command, you can just write it as a Julia function doc string, e.g","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Comonicon\n\n\"\"\"\nmy first Comonicon CLI.\n\"\"\"\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: myscript-help-docstring)","category":"page"},{"location":"","page":"Home","title":"Home","text":"but you might also want to have more detailed help message for your CLI arguments and options, you can specify them via doc string:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"\"\"\nmy command line interface.\n\n# Arguments\n\n- `arg`: an argument\n\n# Options\n\n- `-o, --option`: an option that has short option.\n\n# Flags\n\n- `-f, --flag`: a flag that has short flag.\n\"\"\"\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will give a help message looks like below after execute this in myscript.jl via julia myscript.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: mycmd-option-doc)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, you can directly use this script from command line in this way. But if you want to make it accessible in shell, should do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"create a file without any extension called mycmd\ncopy the script above\nadd the following line on the top of your script mycmd (this is called shebang):","category":"page"},{"location":"","page":"Home","title":"Home","text":"#!<path to your julia executable>","category":"page"},{"location":"","page":"Home","title":"Home","text":"now your mycmd script should look like the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"#!<path to your julia executable>\nusing Comonicon\n\n\"\"\"\nmy first Comonicon CLI.\n\"\"\"\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"now we need to give this file permission via chmod:","category":"page"},{"location":"","page":"Home","title":"Home","text":"chmod +x mycmd","category":"page"},{"location":"","page":"Home","title":"Home","text":"you can now execute this file directly via ./mycmd, if you want to be able to execute  this cmd directly from anywhere in your terminal, you can move this file to .julia/bin  folder, then add .julia/bin to your PATH","category":"page"},{"location":"","page":"Home","title":"Home","text":"export PATH=\"$HOME/.julia/bin:$PATH\"","category":"page"},{"location":"#What's-under-the-hood?","page":"Home","title":"What's under the hood?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Now let me explain what @main does here. In short it does the following things:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parse your expression and create a command line object\nuse this command line object to create an entry (See Conventions section to read about its convention)\ngenerate a Julia script to actually execute the command\ncache the generated Julia script into a file so it won't need to recompile your code again","category":"page"},{"location":"#Developer-Recommendations","page":"Home","title":"Developer Recommendations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For simple and small cases, a CLI script is sufficient.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, for larger projects and more serious usage, one should create a Comonicon CLI project to use the full power of Comonicon. You will be able to gain the following features for free in a Comonicon project:","category":"page"},{"location":"","page":"Home","title":"Home","text":"much faster startup time\nautomatic CLI installation\nmuch easier to deliver it to more users:\ncan be registered and installed as a Julia package\ndistributable system image build in CI (powered by PackageCompiler)\ndistributable standalone application build in CI (powered by PackageCompiler)","category":"page"},{"location":"build/#Build-and-Install-Tools","page":"Build and Install CLI","title":"Build and Install Tools","text":"","category":"section"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"You can use various way to build and install your CLI, this includes:","category":"page"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"use it as a script, and enable or disable compile cache via (Comonicon.disable_cache and Comonicon.enable_cache).\nbuild it as a package and install to ~/.julia/bin:\nuse compile=:min in Comonicon.install if you don't care about the speed\nuse sysimg=true in Comonicon.install if you care about both start up time and the speed","category":"page"},{"location":"build/#Reference","page":"Build and Install CLI","title":"Reference","text":"","category":"section"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"Modules = [Comonicon.Builder]","category":"page"},{"location":"build/#Comonicon.Builder.create_command_env","page":"Build and Install CLI","title":"Comonicon.Builder.create_command_env","text":"create_command_env(m::Module, envpath::String=mktempdir(); test_deps=true)\n\nCreate an environment to execute the CLI command.\n\nArguments\n\nm: the CLI module.\nenvpath: the generated environment path.\n\nKeyword Arguments\n\ntest_deps: include test deps or not.\n\n\n\n\n\n","category":"function"},{"location":"build/#Comonicon.Builder.osname-Tuple{}","page":"Build and Install CLI","title":"Comonicon.Builder.osname","text":"osname()\n\nReturn the name of OS, will be used in building tarball.\n\n\n\n\n\n","category":"method"}]
}
