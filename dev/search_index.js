var documenterSearchIndex = {"docs":
[{"location":"project/#project","page":"Create a CLI project","title":"CLI Project","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"To build better, faster and more complicated CLI, you will want to build your CLI in a Julia package and deliver it to your users. I will introduce how to create a Comonicon CLI project in this chapter.","category":"page"},{"location":"project/#Create-a-Julia-Comonicon-project","page":"Create a CLI project","title":"Create a Julia Comonicon project","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"A Comonicon CLI project is first a Julia project, thus you should first create a Julia project. If you don't know what is a Julia project, please read about the Pkg section of creating packages. The minimal requirement of a Julia Comonicon project is the following structure","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"Demo\n├── LICENSE\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── src\n│   └── Demo.jl\n└── test\n    └── runtests.jl","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"usually it's more convenient to create a Julia project via IonCLI, after you install IonCLI, you can type the following command in your terminal","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"ion create Demo --template=comonicon","category":"page"},{"location":"project/#Use-@cast-to-define-multiple-commands","page":"Create a CLI project","title":"Use @cast to define multiple commands","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"In a large project, one might need to define multiple commands. This can be done via @cast.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"@cast","category":"page"},{"location":"project/#Comonicon.@cast","page":"Create a CLI project","title":"Comonicon.@cast","text":"@cast <function definition>\n@cast <module definition>\n\nDenote a Julia expression is a command. If the expression is a function definition, it will be parsed as a leaf command, if the expression is a module definition or module name, it will be parsed as a node command. This macro must be used with @main to create a multi-command CLI.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@cast function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\n\"product two numbers\"\n@cast function prod(x, y)\n    return\nend\n\n@main\n\n\n\n\n\n","category":"macro"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"@cast is similar to @main before functions, but it won't execute anything, but only create the command and register the command to a global variable CASTED_COMMANDS in the current module. And it will create NodeCommands before modules, and the sub-commands of the NodeCommand can be created via @cast inside the module.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"After you create the commands via @cast, you can declare an entry at the bottom of your module via @main. A simple example looks like the following","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"module Demo\n\nusing Comonicon\n\n@cast mycmd1(arg; option=\"Sam\") = println(\"cmd1: arg=\", arg, \"option=\", option)\n@cast mycmd2(arg; option=\"Sam\") = println(\"cmd2: arg=\", arg, \"option=\", option)\n\n\"\"\"\na module\n\"\"\"\nmodule Cmd3\n\nusing Comonicon\n\n@cast mycmd4(arg) = println(\"cmd4: arg=\", arg)\n\nend # module\n\n@cast Cmd3\n\n\"\"\"\nmy demo Comonicon CLI project.\n\"\"\"\n@main\n\nend # module","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can find all created commands via following","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"julia> Demo.CASTED_COMMANDS\nDict{String,Any} with 4 entries:\n  \"mycmd2\" => mycmd2 [options] <arg>\n  \"cmd3\"   => cmd3 <command>\n  \"main\"   => demo v0.1.0\n  \"mycmd1\" => mycmd1 [options] <arg>","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"and you can execute the command via Demo.command_main created by @main:","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"(Image: project-demo)","category":"page"},{"location":"project/#Setup-the-build.jl","page":"Create a CLI project","title":"Setup the build.jl","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"Then you can create a build.jl file in your package deps folder to install this command to ~/.julia/bin when your user install your package. This will only need one line:","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"# build.jl\nusing Demo; Demo.comonicon_install()","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"To learn about how to use it, you can type","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"julia --project deps/build.jl -h","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"which will print the following help message:","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"(Image: build-help)","category":"page"},{"location":"project/#Install-the-CLI","page":"Create a CLI project","title":"Install the CLI","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can now install the CLI by building the package either in REPL via ]build or use IonCLI in terminal via","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"ion build # in Demo folder","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"This will install this command to ~/.julia/bin directory by default, if you have put this directory in your PATH then you will be able to use the command demo directory in your terminal, e.g","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"demo -h","category":"page"},{"location":"project/#Enable-System-Image","page":"Create a CLI project","title":"Enable System Image","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"Some CLI projects are quite complicated thus the startup latency is still quite huge even the package module is precompiled. In this case, one will want to use a system image to reduce the startup latency.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can enable to the system image build by specifying [sysimg] field in your Comonicon configuration file Comonicon.toml (or JuliaComonicon.toml).","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"name = \"demo\"\n\n[install]\ncompletion = true\nquiet = false\noptimize = 2\n\n[sysimg]","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can also specify more detailed system image compilation options, e.g","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[sysimg]\nincremental=false\nfilter_stdlibs=true","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can find more references for these options in PackageCompiler#create_sysimage.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"However, you may still find it being slow, you can further reduce the latency by adding an execution file to record precompilation statements.","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[sysimg.precompile]\nexecution_file = [\"deps/precompile.jl\"]","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"or you can manually specify these precompile statements via","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[sysimg.precompile]\nstatements_file = [\"deps/statements.jl\"]","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"you can learn more about how to create precompilation statements via SnoopCompile and create a userimg.jl as the precompilation statements.","category":"page"},{"location":"project/#Enable-Application-Build","page":"Create a CLI project","title":"Enable Application Build","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"You can build a standalone application similar to building a system image as well, e.g","category":"page"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"[application]\nincremental=true\nfilter_stdlibs=false\n\n[application.precompile]\nstatements_file = [\"deps/statements.jl\"]","category":"page"},{"location":"project/#Further-Reference","page":"Create a CLI project","title":"Further Reference","text":"","category":"section"},{"location":"project/","page":"Create a CLI project","title":"Create a CLI project","text":"The CLI we just used to create this project serves as the best practice for Comonicon, you can take it as a reference: IonCLI.jl.","category":"page"},{"location":"parse/#Parse","page":"Command Parsing","title":"Parse","text":"","category":"section"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"This is the frontend @cast and @main of Comonicon.","category":"page"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"The @main command will use generate the following functions in the module:","category":"page"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"the entry function for CLI command_main.\ncomonicon_install: for command build and installation.\ncomonicon_install_path: for path build and installation.\njulia_main: for building standalone applications.","category":"page"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"And a registry constant CASTED_COMMANDS in the module, one can find the original Comonicon AST by indexing CASTED_COMMANDS by your command name.","category":"page"},{"location":"parse/#References","page":"Command Parsing","title":"References","text":"","category":"section"},{"location":"parse/","page":"Command Parsing","title":"Command Parsing","text":"Modules = [Comonicon]","category":"page"},{"location":"parse/#Comonicon.Comonicon","page":"Command Parsing","title":"Comonicon.Comonicon","text":"All the terminals are under my command. Comonicon is a CLI (Command Line Interface) generator that features light-weight dependency (optional to have zero dependency), fast start-up time and easy to use. See the website for more info.\n\n\n\n\n\n","category":"module"},{"location":"parse/#Comonicon.default_name-Tuple{String}","page":"Command Parsing","title":"Comonicon.default_name","text":"default_name(x::String)\n\nReturn the lowercase of a given package name. It will ignore the suffix if it ends with \".jl\".\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.get_version-Tuple{Module}","page":"Command Parsing","title":"Comonicon.get_version","text":"get_version(m::Module)\n\nGet the version of a given module. It will try to find the version of Project.toml if the given module is a project module. If fails, it returns v\"0.0.0\".\n\n\n\n\n\n","category":"method"},{"location":"parse/#Comonicon.rm_format","page":"Command Parsing","title":"Comonicon.rm_format","text":"rm_format(md)\n\nRemove Markdown DOM and flatten to strings.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.set_cmd!","page":"Command Parsing","title":"Comonicon.set_cmd!","text":"set_cmd!(cmds::Dict, cmd)\n\nregister cmd in the command registry cmds, which usually is a constant CASTED_COMMANDS under given module.\n\n\n\n\n\n","category":"function"},{"location":"parse/#Comonicon.@cast-Tuple{Any}","page":"Command Parsing","title":"Comonicon.@cast","text":"@cast <function definition>\n@cast <module definition>\n\nDenote a Julia expression is a command. If the expression is a function definition, it will be parsed as a leaf command, if the expression is a module definition or module name, it will be parsed as a node command. This macro must be used with @main to create a multi-command CLI.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@cast function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\n\"product two numbers\"\n@cast function prod(x, y)\n    return\nend\n\n@main\n\n\n\n\n\n","category":"macro"},{"location":"parse/#Comonicon.@main-Tuple{}","page":"Command Parsing","title":"Comonicon.@main","text":"@main\n@main <function definition>\n\nMain entry of the CLI application.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@main function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\nCLI Definitions and Julia Syntax Mapping\n\npositional arguments normal inputs, these are mapped as Julia function arguments, e.g\n\nsum 1 2\n\nsum is the command, and 1, 2 are positional arguments.\n\noptions arguments with syntax --<name>=<value> or --<name> <value>, these are mapped as Julia keyword arguments, e.g\n\nsum --precision=float32 1 2\n\n--precision is the option of command sum and has value float32.\n\nshort options arguments with syntax -<letter>=<value> or -<letter><value> or --<letter> <value>, the letter is usually the first character of a normal option, e.g\n\nsum -pfloat32 1 2\n\n-p is the same as --precision, but in short hand, this is enabled by writing corresponding docstring (see the next section on docstring syntax).\n\nflags like options, but without any value, e.g --<name>, this is mapped to a special type of keyword argument that is of type Bool and has default value false, e.g\n\nsum --fastmath\n\nshort flags flags with syntax -<letter>, the letter should be the first character of the corresponding normal flag, e.g\n\nsum -f\n\nDoc String Syntax\n\nEach different kind of inputs must have a different level-1 section (markdown syntax #<section name>).\n\nThe docstring must have section name:\n\n#Args or #Arguments to declare the documentation   of positional arguments.\n#Options to declare the documentation of options.\n#Flags to declare the documentation of flags.\n\nExamples\n\nThe simplest usage is creating the following commands\n\n\"\"\"\nan example command\n\n# Args\n\n- `x`: first argument\n- `y`: second argument\n- `z`: last argument\n\n# Flags\n\n- `-f, --flag`: a flag, optionally can be a short flag.\n\n# Options\n\n- `-o, --option=<int>`: an option, optionally can be short option.\n\n\"\"\"\n@cast function mycommand(x, y, z; flag::Bool=false, option::Int=2)\n    # some implementation\n    return\nend\n\n@cast function myothercommand(xs...)\n    # another command with variatic arguments\n    return\nend\n\n\"\"\"\nMy main command.\n\"\"\"\n@main # declare the entry\n\nthis can be used in command line as mycommand 1 2 3 --flag, you can also just type -h to check the detailed help info.\n\nThe command line documentation will be generated automatically from your Julia docstring.\n\nIf you have deeper hierachy of commands, you can also put @cast on a Julia module.\n\n@cast module NodeCommand\n\nusing Comonicon\n@cast foo(x) = nothing\n\nend\n\n\n\n\n\n","category":"macro"},{"location":"types/#Command-Types","page":"Command Types","title":"Command Types","text":"","category":"section"},{"location":"types/","page":"Command Types","title":"Command Types","text":"The frontend @main and @cast restrict a lot features to make the package interface as simple as possible. However, if you want to customize the behaviour, you can also create command objects directly via the interfaces at this level, which are all in Comonicon.AST.","category":"page"},{"location":"types/#References","page":"Command Types","title":"References","text":"","category":"section"},{"location":"types/","page":"Command Types","title":"Command Types","text":"Modules = [Comonicon.AST]","category":"page"},{"location":"types/#Comonicon.AST.brief-Tuple{String}","page":"Command Types","title":"Comonicon.AST.brief","text":"brief(text::String)\n\nUse the first sentence as the brief description.\n\n\n\n\n\n","category":"method"},{"location":"types/#Comonicon.AST.splitlines","page":"Command Types","title":"Comonicon.AST.splitlines","text":"splitlines(s, width = 80)\n\nSplit a given string into lines of width 80 characters.\n\n\n\n\n\n","category":"function"},{"location":"types/#Comonicon.AST.splittext-Tuple{String}","page":"Command Types","title":"Comonicon.AST.splittext","text":"splittext(s)\n\nSplit the text in string s into an array, but keep all the separators attached to the preceding word.\n\nnote: Note\nthis is copied from Luxor/text.jl\n\n\n\n\n\n","category":"method"},{"location":"conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"leaf command: leaf commands are the commands at the last of the CLI that takes arguments, options and flags, e.g the show command below","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"node command: node commands are the commands at the middle or first of the CLI that contains sub-commands, e.g the remote command below","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"git remote show origin","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"arguments: arguments are command line arguments that required at the leaf command","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"flags: flags are command line options that has no arguments, e.g --flag or -f (short flag).","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"options: options are command line options that has arguments, e.g --name Sam or -n Sam, also --name=Sam or -nSam.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"When used on function expressions, @cast and @main have the same convention on how they convert your expressions to commands, these are","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"function arguments are parsed as command arguments:\nvalue will be converted automatically if arguments has type annotation\noptional arguments are allowed\nfunction keyword arguments are parsed as command flags or options:\nkeyword arguments must have default value\nkeyword arguments of type Bool can only have false as default value, which will be treated as flags that allow short flags.\nvalue will be converted automatically if keyword arguments has type annotation\nfunction doc string can use section names: Arguments, Options and Flags to annotate your CLI:\nshort options or short flags can be declared via -f, flag or -o, --option <name> (see example below)","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"note: Note\nto be compatible with shell options, variable names with underscore _ will be automatically replaced with dash -.   As a result, the corresponding doc string should use dash - instead of _ as well, e.g kwargs name dash_dash will be converted to --dash-dash option/flag in terminal, and its corresponding doc string should be - `--dash-dash`: <arg>.","category":"page"},{"location":"configurations/#Configurations","page":"Command Configuration","title":"Configurations","text":"","category":"section"},{"location":"configurations/","page":"Command Configuration","title":"Command Configuration","text":"Configurations can be defined via a TOML file, it should be named as either Comonicon.toml or JuliaComonicon.toml under a Julia project project root directory.","category":"page"},{"location":"configurations/#References","page":"Command Configuration","title":"References","text":"","category":"section"},{"location":"configurations/","page":"Command Configuration","title":"Command Configuration","text":"Modules = [Comonicon.Options]","category":"page"},{"location":"configurations/#Comonicon.Options.Application","page":"Command Configuration","title":"Comonicon.Options.Application","text":"Application\n\nApplication build configurations.\n\nKeywords\n\npath: application build path, default is \"build\".\nincremental: set to true to build incrementally, default is true.\nfilter_stdlibs: set to true to filter out unused stdlibs, default is false.\ncpu_target: cpu target to build, default is PackageCompiler.default_app_cpu_target().\nprecompile: precompile configurations, see Precompile, default is Precompile().\nc_driver_program: driver program.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Options.Comonicon","page":"Command Configuration","title":"Comonicon.Options.Comonicon","text":"Comonicon\n\nBuild configurations for Comonicon. One can set this option via Comonicon.toml under the root path of a Julia project directory and read in using read_configs.\n\nKeywords\n\nname: required, the name of CLI file to install.\ninstall: installation options, see also Install.\nsysimg: system image build options, see also SysImg.\ndownload: download options, see also Download.\napplication: application build options, see also Application.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Options.Download","page":"Command Configuration","title":"Comonicon.Options.Download","text":"Download\n\nDownload information.\n\nKeywords\n\nhost: where are the tarballs hosted, default is \"github.com\"\nuser: required, user name on the host.\nrepo: required, repo name on the host.\n\nnote: Note\nCurrently this only supports github, and this is considered experimental.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Options.Install","page":"Command Configuration","title":"Comonicon.Options.Install","text":"Install\n\nInstallation configurations.\n\nKeywords\n\npath: installation path.\ncompletion: set to true to install shell auto-completion scripts.\nquiet: print logs or not, default is false.\ncompile: julia compiler option for CLIs if not built as standalone application, default is \"min\".\noptimize: julia compiler option for CLIs if not built as standalone application, default is 2.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Options.Precompile","page":"Command Configuration","title":"Comonicon.Options.Precompile","text":"Precompile\n\nPrecompilation files for PackageCompiler.\n\nKeywords\n\nexecution_file: precompile execution file.\nstatements_file: precompile statements file.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Options.SysImg","page":"Command Configuration","title":"Comonicon.Options.SysImg","text":"SysImg\n\nSystem image build configurations.\n\nKeywords\n\npath: system image path to generate into, default is \"deps/lib\".\nincremental: set to true to build incrementally, default is true.\nfilter_stdlibs: set to true to filter out unused stdlibs, default is false.\ncpu_target: cpu target to build, default is PackageCompiler.default_app_cpu_target().\nprecompile: precompile configurations, see Precompile, default is Precompile().\n\n\n\n\n\n","category":"type"},{"location":"configurations/#Comonicon.Options.find_comonicon_toml","page":"Command Configuration","title":"Comonicon.Options.find_comonicon_toml","text":"find_comonicon_toml(path::String, files=[\"Comonicon.toml\", \"JuliaComonicon.toml\"])\n\nFind Comonicon.toml or JuliaComonicon.toml in given path.\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Comonicon.Options.read_options-Tuple{Union{Module, String}}","page":"Command Configuration","title":"Comonicon.Options.read_options","text":"read_options(comonicon; kwargs...)\n\nRead in Comonicon build options. The argument comonicon can be:\n\na module of a Comonicon CLI project.\na path to a Comonicon CLI project that contains either JuliaComonicon.toml or Comonicon.toml.\na path to a Comonicon CLI build configuration file named either JuliaComonicon.toml or Comonicon.toml.\n\nIn some cases, you might want to change the configuration written in the TOML file temporarily, e.g for writing build tests etc. In this case, you can modify the configuration using corresponding keyword arguments.\n\nkeyword arguments of Application and SysImg are the same, thus keys like filter_stdlibs are considered ambiguous in read_options, but you can specifiy them by specifiy the specific Application or SysImg object, e.g\n\nread_options(MyCLI; sysimg=SysImg(filter_stdlibs=false))\n\nSee also Comonicon, Install, SysImg, Application, Download, Precompile.\n\n\n\n\n\n","category":"method"},{"location":"configurations/#Comonicon.Options.read_toml-Tuple{Module}","page":"Command Configuration","title":"Comonicon.Options.read_toml","text":"read_toml(mod::Module)\n\nRead Comonicon.toml or JuliaComonicon.toml in given module's project path.\n\n\n\n\n\n","category":"method"},{"location":"configurations/#Comonicon.Options.read_toml-Tuple{String}","page":"Command Configuration","title":"Comonicon.Options.read_toml","text":"read_toml(path::String)\n\nRead Comonicon.toml or JuliaComonicon.toml in given path.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Code-Generation","page":"Code Generation","title":"Code Generation","text":"","category":"section"},{"location":"codegen/","page":"Code Generation","title":"Code Generation","text":"This is the backend of Comonicon. Currently it can only generates a Julia AST.","category":"page"},{"location":"codegen/#References","page":"Code Generation","title":"References","text":"","category":"section"},{"location":"codegen/","page":"Code Generation","title":"Code Generation","text":"Modules = [Comonicon.JuliaExpr]","category":"page"},{"location":"codegen/#Comonicon.JuliaExpr.emit","page":"Code Generation","title":"Comonicon.JuliaExpr.emit","text":"emit(cmd::Entry[, ptr::Int=1])\n\nEmit Expr from a Entry.\n\n\n\n\n\n","category":"function"},{"location":"#Comonicon","page":"Home","title":"Comonicon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"gith averminaluk ayh juldas mausan urdan","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Roger's magic book for command line interfaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Comonicon","category":"page"},{"location":"#Comonicon","page":"Home","title":"Comonicon","text":"All the terminals are under my command. Comonicon is a CLI (Command Line Interface) generator that features light-weight dependency (optional to have zero dependency), fast start-up time and easy to use. See the website for more info.\n\n\n\n\n\n","category":"module"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest and most common way to use Comonicon is to use @cast and @main.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@main","category":"page"},{"location":"#Comonicon.@main","page":"Home","title":"Comonicon.@main","text":"@main\n@main <function definition>\n\nMain entry of the CLI application.\n\nQuick Example\n\n# in a script or module\n\n\"\"\"\nsum two numbers.\n\n# Args\n\n- `x`: first number\n- `y`: second number\n\n# Options\n\n- `-p, --precision=<type>`: precision of the calculation.\n\n# Flags\n\n- `-f, --fastmath`: enable fastmath.\n\n\"\"\"\n@main function sum(x, y; precision::String=\"float32\", fastmath::Bool=false)\n    # implementation\n    return\nend\n\nCLI Definitions and Julia Syntax Mapping\n\npositional arguments normal inputs, these are mapped as Julia function arguments, e.g\n\nsum 1 2\n\nsum is the command, and 1, 2 are positional arguments.\n\noptions arguments with syntax --<name>=<value> or --<name> <value>, these are mapped as Julia keyword arguments, e.g\n\nsum --precision=float32 1 2\n\n--precision is the option of command sum and has value float32.\n\nshort options arguments with syntax -<letter>=<value> or -<letter><value> or --<letter> <value>, the letter is usually the first character of a normal option, e.g\n\nsum -pfloat32 1 2\n\n-p is the same as --precision, but in short hand, this is enabled by writing corresponding docstring (see the next section on docstring syntax).\n\nflags like options, but without any value, e.g --<name>, this is mapped to a special type of keyword argument that is of type Bool and has default value false, e.g\n\nsum --fastmath\n\nshort flags flags with syntax -<letter>, the letter should be the first character of the corresponding normal flag, e.g\n\nsum -f\n\nDoc String Syntax\n\nEach different kind of inputs must have a different level-1 section (markdown syntax #<section name>).\n\nThe docstring must have section name:\n\n#Args or #Arguments to declare the documentation   of positional arguments.\n#Options to declare the documentation of options.\n#Flags to declare the documentation of flags.\n\nExamples\n\nThe simplest usage is creating the following commands\n\n\"\"\"\nan example command\n\n# Args\n\n- `x`: first argument\n- `y`: second argument\n- `z`: last argument\n\n# Flags\n\n- `-f, --flag`: a flag, optionally can be a short flag.\n\n# Options\n\n- `-o, --option=<int>`: an option, optionally can be short option.\n\n\"\"\"\n@cast function mycommand(x, y, z; flag::Bool=false, option::Int=2)\n    # some implementation\n    return\nend\n\n@cast function myothercommand(xs...)\n    # another command with variatic arguments\n    return\nend\n\n\"\"\"\nMy main command.\n\"\"\"\n@main # declare the entry\n\nthis can be used in command line as mycommand 1 2 3 --flag, you can also just type -h to check the detailed help info.\n\nThe command line documentation will be generated automatically from your Julia docstring.\n\nIf you have deeper hierachy of commands, you can also put @cast on a Julia module.\n\n@cast module NodeCommand\n\nusing Comonicon\n@cast foo(x) = nothing\n\nend\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"Let's use a simple example to show how, the following example creates a command using @main.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Comonicon\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you write this into a script file myscript.jl and execute it using","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia myscript.jl -h","category":"page"},{"location":"","page":"Home","title":"Home","text":"You will see the following in your terminal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: myscript-help)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to add some description to your command, you can just write it as a Julia function doc string, e.g","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Comonicon\n\n\"\"\"\nmy first Comonicon CLI.\n\"\"\"\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: myscript-help-docstring)","category":"page"},{"location":"","page":"Home","title":"Home","text":"but you might also want to have more detailed help message for your CLI arguments and options, you can specify them via doc string:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"\"\"\nmy command line interface.\n\n# Arguments\n\n- `arg`: an argument\n\n# Options\n\n- `-o, --option`: an option that has short option.\n\n# Flags\n\n- `-f, --flag`: a flag that has short flag.\n\"\"\"\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will give a help message looks like below after execute this in myscript.jl via julia myscript.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: mycmd-option-doc)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, you can directly use this script from command line in this way. But if you want to make it accessible in shell, should do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"create a file without any extension called mycmd\ncopy the script above\nadd the following line on the top of your script mycmd (this is called shebang):","category":"page"},{"location":"","page":"Home","title":"Home","text":"#!<path to your julia executable>","category":"page"},{"location":"","page":"Home","title":"Home","text":"now your mycmd script should look like the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"#!<path to your julia executable>\nusing Comonicon\n\n\"\"\"\nmy first Comonicon CLI.\n\"\"\"\n@main function mycmd(arg; option=\"Sam\", flag::Bool=false)\n    @show arg\n    @show option\n    @show flag\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"now we need to give this file permission via chmod:","category":"page"},{"location":"","page":"Home","title":"Home","text":"chmod +x mycmd","category":"page"},{"location":"","page":"Home","title":"Home","text":"you can now execute this file directly via ./mycmd, if you want to be able to execute  this cmd directly from anywhere in your terminal, you can move this file to .julia/bin  folder, then add .julia/bin to your PATH","category":"page"},{"location":"","page":"Home","title":"Home","text":"export PATH=\"$HOME/.julia/bin:$PATH\"","category":"page"},{"location":"#What's-under-the-hood?","page":"Home","title":"What's under the hood?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Now let me explain what @main does here. In short it does the following things:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parse your expression and create a command line object\nuse this command line object to create an entry (See Conventions section to read about its convention)\ngenerate a Julia script to actually execute the command\ncache the generated Julia script into a file so it won't need to recompile your code again","category":"page"},{"location":"#Developer-Recommendations","page":"Home","title":"Developer Recommendations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For simple and small cases, a CLI script is sufficient.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, for larger projects and more serious usage, one should create a Comonicon CLI project to use the full power of Comonicon. You will be able to gain the following features for free in a Comonicon project:","category":"page"},{"location":"","page":"Home","title":"Home","text":"much faster startup time\nautomatic CLI installation\nmuch easier to deliver it to more users:\ncan be registered and installed as a Julia package\ndistributable system image build in CI (powered by PackageCompiler)\ndistributable standalone application build in CI (powered by PackageCompiler)","category":"page"},{"location":"build/#Build-and-Install-Tools","page":"Build and Install CLI","title":"Build and Install Tools","text":"","category":"section"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"You can use various way to build and install your CLI, this includes:","category":"page"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"use it as a script, and enable or disable compile cache via (Comonicon.disable_cache and Comonicon.enable_cache).\nbuild it as a package and install to ~/.julia/bin:\nuse compile=:min in Comonicon.install if you don't care about the speed\nuse sysimg=true in Comonicon.install if you care about both start up time and the speed","category":"page"},{"location":"build/#Reference","page":"Build and Install CLI","title":"Reference","text":"","category":"section"},{"location":"build/","page":"Build and Install CLI","title":"Build and Install CLI","text":"Modules = [Comonicon.Builder]","category":"page"},{"location":"build/#Comonicon.Builder.create_command_env","page":"Build and Install CLI","title":"Comonicon.Builder.create_command_env","text":"create_command_env(m::Module, envpath::String=mktempdir(); test_deps=true)\n\nCreate an environment to execute the CLI command.\n\nArguments\n\nm: the CLI module.\nenvpath: the generated environment path.\n\nKeyword Arguments\n\ntest_deps: include test deps or not.\n\n\n\n\n\n","category":"function"},{"location":"build/#Comonicon.Builder.osname-Tuple{}","page":"Build and Install CLI","title":"Comonicon.Builder.osname","text":"osname()\n\nReturn the name of OS, will be used in building tarball.\n\n\n\n\n\n","category":"method"}]
}
